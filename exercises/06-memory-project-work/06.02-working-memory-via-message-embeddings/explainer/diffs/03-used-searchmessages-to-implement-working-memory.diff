commit 1435d5e82672a6a29c372c77c75026192f988485
Author: Matt Pocock <team@aihero.dev>
Date:   Wed Nov 5 14:33:30 2025 +0000

    06.02.03 Used searchMessages to implement working memory

diff --git a/src/app/api/chat/route.ts b/src/app/api/chat/route.ts
index 901dd70..3c044df 100644
--- a/src/app/api/chat/route.ts
+++ b/src/app/api/chat/route.ts
@@ -22,6 +22,7 @@ import { filterEmailsTool } from "./filter-tool";
 import { getEmailsTool } from "./get-emails-tool";
 import { memoryToText, searchMemories } from "@/app/memory-search";
 import { extractAndUpdateMemories } from "./extract-memories";
+import { searchMessages } from "@/app/message-search";
 
 // Allow streaming responses up to 30 seconds
 export const maxDuration = 30;
@@ -29,6 +30,8 @@ export const maxDuration = 30;
 const USER_FIRST_NAME = "Sarah";
 const USER_LAST_NAME = "Chen";
 const MEMORIES_TO_USE = 3;
+const MESSAGE_HISTORY_LENGTH = 10;
+const OLD_MESSAGES_TO_USE = 10;
 
 export type MyMessage = UIMessage<
   never,
@@ -47,75 +50,95 @@ const getTools = (messages: UIMessage[]) => ({
 export async function POST(req: Request) {
   const body: {
     message: MyMessage;
     id: string;
   } = await req.json();
 
   const chatId = body.id;
 
   let chat = await getChat(chatId);
 
+  const recentMessages = [...(chat?.messages ?? []), body.message].slice(
+    -MESSAGE_HISTORY_LENGTH
+  );
+
+  const olderMessages = chat?.messages.slice(0, -MESSAGE_HISTORY_LENGTH);
+
   const validatedMessagesResult = await safeValidateUIMessages<MyMessage>({
-    messages: [...(chat?.messages ?? []), body.message],
+    messages: recentMessages,
   });
 
   if (!validatedMessagesResult.success) {
     return new Response(validatedMessagesResult.error.message, { status: 400 });
   }
 
   const messages = validatedMessagesResult.data;
 
   const mostRecentMessage = messages[messages.length - 1];
 
   if (!mostRecentMessage) {
     return new Response("No messages provided", { status: 400 });
   }
 
   if (mostRecentMessage.role !== "user") {
     return new Response("Last message must be from the user", {
       status: 400,
     });
   }
 
   const allMemories = await searchMemories({ messages });
 
   const memories = allMemories.slice(0, MEMORIES_TO_USE);
 
+  const oldMessagesToUse = await searchMessages({
+    recentMessages: messages,
+    olderMessages: olderMessages ?? [],
+  }).then((results) =>
+    results
+      .slice(0, OLD_MESSAGES_TO_USE)
+      .sort((a, b) => b.score - a.score)
+      .map((result) => result.item)
+  );
+
+  console.log("oldMessagesToUse", oldMessagesToUse.length);
+
+  const messageHistoryForLLM = [...oldMessagesToUse, ...messages];
+
   const stream = createUIMessageStream<MyMessage>({
     execute: async ({ writer }) => {
       let generateTitlePromise: Promise<void> | undefined = undefined;
 
       if (!chat) {
         const newChat = await createChat({
           id: chatId,
           title: "Generating title...",
           initialMessages: messages,
         });
         chat = newChat;
 
         writer.write({
           type: "data-frontend-action",
           data: "refresh-sidebar",
           transient: true,
         });
 
         generateTitlePromise = generateTitleForChat(messages)
           .then((title) => {
             return updateChatTitle(chatId, title);
           })
           .then(() => {
             writer.write({
               type: "data-frontend-action",
               data: "refresh-sidebar",
               transient: true,
             });
           });
       } else {
         await appendToChatMessages(chatId, [mostRecentMessage]);
       }
 
       const result = streamText({
         model: google("gemini-2.5-flash"),
-        messages: convertToModelMessages(messages),
+        messages: convertToModelMessages(messageHistoryForLLM),
         system: `
 <task-context>
 You are a personal assistant to ${USER_FIRST_NAME} ${USER_LAST_NAME}. You help with general tasks, questions, and can access ${USER_FIRST_NAME}'s email when needed.
