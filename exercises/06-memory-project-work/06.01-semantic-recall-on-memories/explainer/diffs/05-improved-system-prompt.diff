commit f07bc29fae5004f5516bc32247853d32fda0571e
Author: Matt Pocock <team@aihero.dev>
Date:   Wed Nov 5 14:17:38 2025 +0000

    06.01.05 Improved system prompt

diff --git a/src/app/api/chat/route.ts b/src/app/api/chat/route.ts
index d668524..916be6a 100644
--- a/src/app/api/chat/route.ts
+++ b/src/app/api/chat/route.ts
@@ -26,6 +26,8 @@ import { extractAndUpdateMemories } from "./extract-memories";
 // Allow streaming responses up to 30 seconds
 export const maxDuration = 30;
 
+const USER_FIRST_NAME = "Sarah";
+const USER_LAST_NAME = "Chen";
 const MEMORIES_TO_USE = 3;
 
 export type MyMessage = UIMessage<
@@ -113,45 +115,47 @@ export async function POST(req: Request) {
       const result = streamText({
         model: google("gemini-2.5-flash"),
         messages: convertToModelMessages(messages),
         system: `
 <task-context>
-You are an email assistant that helps users find and understand information from their emails.
+You are a personal assistant to ${USER_FIRST_NAME} ${USER_LAST_NAME}. You help with general tasks, questions, and can access ${USER_FIRST_NAME}'s email when needed.
 </task-context>
 
 <rules>
-- You have THREE tools available: 'search', 'filterEmails', and 'getEmails'
-- Follow this multi-step workflow for token efficiency:
+- You have THREE email tools available: 'search', 'filterEmails', and 'getEmails'
+- Use these tools ONLY when the user explicitly asks about emails or information likely contained in emails
+- For general questions, conversations, or tasks unrelated to email, respond naturally without using tools
+- When you do need to access emails, follow this multi-step workflow for token efficiency:
 
   STEP 1 - Browse metadata:
   USE 'filterEmails' when the user wants to:
   - Find emails from/to specific people (e.g., "emails from John", "emails to sarah@example.com")
   - Filter by date ranges (e.g., "emails before January 2024", "emails after last week")
   - Find emails containing exact text (e.g., "emails containing 'invoice'")
   - Any combination of precise filtering criteria
 
   USE 'search' when the user wants to:
   - Find information semantically (e.g., "emails about the project deadline")
   - Search by concepts or topics (e.g., "discussions about budget")
   - Find answers to questions (e.g., "what did John say about the meeting?")
   - Any query requiring understanding of meaning/context
   - Find people by name or description (e.g., "Mike's biggest client")
 
   NOTE: 'search' and 'filterEmails' return metadata with snippets only (id, threadId, subject, from, to, timestamp, snippet)
 
   STEP 2 - Review and select:
   - Review the subjects, metadata, and snippets from search/filter results
   - Identify which specific emails need full content to answer the user's question
   - If snippets contain enough info, answer directly without fetching full content
 
   STEP 3 - Fetch full content:
   USE 'getEmails' to retrieve full email bodies:
   - Pass array of email IDs you need to read completely
   - Set includeThread=true if you need conversation context (replies, full thread)
   - Set includeThread=false for individual emails
 
-- NEVER answer from your training data - always use tools first
+- For email-related queries, NEVER answer from your training data - always use tools first
 - If the first query doesn't find enough information, try different approaches or tools
 - Only after using tools should you formulate your answer based on the results
 </rules>
 
 <memories>
@@ -167,34 +171,34 @@ ${memories
 </memories>
 
 <the-ask>
-Here is the user's question. Follow the multi-step workflow above to efficiently find and retrieve the information.
+Here is the user's request. For general questions and conversations, respond naturally. For email-related queries, use the tools and multi-step workflow above.
 </the-ask>
         `,
         tools: getTools(messages),
         stopWhen: [stepCountIs(10)],
       });
 
       writer.merge(
         result.toUIMessageStream({
           sendSources: true,
           sendReasoning: true,
         })
       );
 
       await generateTitlePromise;
     },
     generateId: () => crypto.randomUUID(),
     onFinish: async ({ responseMessage }) => {
       await appendToChatMessages(chatId, [responseMessage]);
       await extractAndUpdateMemories({
         messages: [...messages, responseMessage],
         memories: memories.map((memory) => memory.item),
       });
     },
   });
 
   // send sources and reasoning back to the client
   return createUIMessageStreamResponse({
     stream,
   });
 }
