commit 25203ff335fbdd7da7d7cfa6f2be3417e1ae7c34
Author: Matt Pocock <team@aihero.dev>
Date:   Wed Nov 5 15:39:23 2025 +0000

    06.01.03 Added memories to the agent

diff --git a/src/app/api/chat/route.ts b/src/app/api/chat/route.ts
index e7822a1..b895bcd 100644
--- a/src/app/api/chat/route.ts
+++ b/src/app/api/chat/route.ts
@@ -20,10 +20,13 @@ import { generateTitleForChat } from "./generate-title";
 import { searchTool } from "./search-tool";
 import { filterEmailsTool } from "./filter-tool";
 import { getEmailsTool } from "./get-emails-tool";
+import { memoryToText, searchMemories } from "@/app/memory-search";
 
 // Allow streaming responses up to 30 seconds
 export const maxDuration = 30;
 
+const MEMORIES_TO_USE = 3;
+
 export type MyMessage = UIMessage<
   never,
   {
@@ -41,111 +44,121 @@ const getTools = (messages: UIMessage[]) => ({
 export async function POST(req: Request) {
   const body: {
     messages: UIMessage[];
     id: string;
   } = await req.json();
 
   const chatId = body.id;
 
   const validatedMessagesResult = await safeValidateUIMessages<MyMessage>({
     messages: body.messages,
   });
 
   if (!validatedMessagesResult.success) {
     return new Response(validatedMessagesResult.error.message, { status: 400 });
   }
 
   const messages = validatedMessagesResult.data;
 
   let chat = await getChat(chatId);
   const mostRecentMessage = messages[messages.length - 1];
 
   if (!mostRecentMessage) {
     return new Response("No messages provided", { status: 400 });
   }
 
   if (mostRecentMessage.role !== "user") {
     return new Response("Last message must be from the user", {
       status: 400,
     });
   }
 
+  const allMemories = await searchMemories({ messages });
+
+  const memories = allMemories.slice(0, MEMORIES_TO_USE);
+
   const stream = createUIMessageStream<MyMessage>({
     execute: async ({ writer }) => {
       let generateTitlePromise: Promise<void> | undefined = undefined;
 
       if (!chat) {
         const newChat = await createChat({
           id: chatId,
           title: "Generating title...",
           initialMessages: messages,
         });
         chat = newChat;
 
         writer.write({
           type: "data-frontend-action",
           data: "refresh-sidebar",
           transient: true,
         });
 
         generateTitlePromise = generateTitleForChat(messages)
           .then((title) => {
             return updateChatTitle(chatId, title);
           })
           .then(() => {
             writer.write({
               type: "data-frontend-action",
               data: "refresh-sidebar",
               transient: true,
             });
           });
       } else {
         await appendToChatMessages(chatId, [mostRecentMessage]);
       }
 
       const result = streamText({
         model: google("gemini-2.5-flash"),
         messages: convertToModelMessages(messages),
         system: `
 <task-context>
 You are an email assistant that helps users find and understand information from their emails.
 </task-context>
 
 <rules>
 - You have THREE tools available: 'search', 'filterEmails', and 'getEmails'
 - Follow this multi-step workflow for token efficiency:
 
   STEP 1 - Browse metadata:
   USE 'filterEmails' when the user wants to:
   - Find emails from/to specific people (e.g., "emails from John", "emails to sarah@example.com")
   - Filter by date ranges (e.g., "emails before January 2024", "emails after last week")
   - Find emails containing exact text (e.g., "emails containing 'invoice'")
   - Any combination of precise filtering criteria
 
   USE 'search' when the user wants to:
   - Find information semantically (e.g., "emails about the project deadline")
   - Search by concepts or topics (e.g., "discussions about budget")
   - Find answers to questions (e.g., "what did John say about the meeting?")
   - Any query requiring understanding of meaning/context
   - Find people by name or description (e.g., "Mike's biggest client")
 
   NOTE: 'search' and 'filterEmails' return metadata with snippets only (id, threadId, subject, from, to, timestamp, snippet)
 
   STEP 2 - Review and select:
   - Review the subjects, metadata, and snippets from search/filter results
   - Identify which specific emails need full content to answer the user's question
   - If snippets contain enough info, answer directly without fetching full content
 
   STEP 3 - Fetch full content:
   USE 'getEmails' to retrieve full email bodies:
   - Pass array of email IDs you need to read completely
   - Set includeThread=true if you need conversation context (replies, full thread)
   - Set includeThread=false for individual emails
 
 - NEVER answer from your training data - always use tools first
 - If the first query doesn't find enough information, try different approaches or tools
 - Only after using tools should you formulate your answer based on the results
 </rules>
 
+<memories>
+Here are some memories that may be relevant to the conversation:
+
+${memories.map((memory) => `- ${memoryToText(memory.item)}`).join("\n")}
+</memories>
+
 <the-ask>
 Here is the user's question. Follow the multi-step workflow above to efficiently find and retrieve the information.
 </the-ask>
