commit b5613c116b16d557a07bcce64d9ce0ebb5e5444b
Author: Matt Pocock <team@aihero.dev>
Date:   Wed Nov 5 16:21:38 2025 +0000

    06.01.04 Added memory extraction

diff --git a/src/app/api/chat/extract-memories.ts b/src/app/api/chat/extract-memories.ts
new file mode 100644
index 0000000..9cab9a6
--- /dev/null
+++ b/src/app/api/chat/extract-memories.ts
@@ -0,0 +1,119 @@
+import {
+  createMemory,
+  DB,
+  deleteMemory,
+  loadMemories,
+  updateMemory,
+} from "@/lib/persistence-layer";
+import { google } from "@ai-sdk/google";
+import { convertToModelMessages, generateObject } from "ai";
+import { z } from "zod";
+import { MyMessage } from "./route";
+import { memoryToText } from "@/app/memory-search";
+
+export async function extractAndUpdateMemories(opts: {
+  messages: MyMessage[];
+  memories: DB.Memory[];
+}) {
+  // Only include user and assistant messages, not tool calls
+  // This is a cost-saving measure
+  const filteredMessages = opts.messages.filter(
+    (message) => message.role === "user" || message.role === "assistant"
+  );
+
+  const memoriesResult = await generateObject({
+    model: google("gemini-2.5-flash"),
+    schema: z.object({
+      updates: z
+        .array(
+          z.object({
+            id: z.string().describe("The ID of the existing memory to update"),
+            title: z.string().describe("The updated memory title"),
+            content: z.string().describe("The updated memory content"),
+          })
+        )
+        .describe("Memories to update"),
+      deletions: z.array(z.string()).describe("Array of memory IDs to delete"),
+      additions: z
+        .array(
+          z.object({
+            title: z.string().describe("The memory title"),
+            content: z.string().describe("The memory content"),
+          })
+        )
+        .describe("New memories to add"),
+    }),
+    system: `You are a memory management agent that extracts and maintains permanent information about the user from conversations.
+
+<existing-memories>
+${opts.memories
+  .map((memory) => `<memory id="${memory.id}">${memoryToText(memory)}</memory>`)
+  .join("\n\n")}
+</existing-memories>
+
+Your job is to:
+1. Analyze the conversation history
+2. Extract NEW permanent facts worth remembering
+3. Update existing memories if they should be modified
+4. Delete memories that are no longer relevant or accurate
+
+Only store PERMANENT information that:
+- Is unlikely to change over time (preferences, traits, characteristics)
+- Will be relevant for weeks, months, or years
+- Helps personalize future interactions
+- Represents lasting facts about the user
+
+Examples of what TO store:
+- "User prefers dark mode in applications"
+- "User works as a software engineer at Acme Corp"
+- "User's primary programming language is TypeScript"
+- "User has a cat named Whiskers"
+
+Examples of what NOT to store:
+- "User asked about the weather today"
+- "User said hello"
+- "User is working on a project" (too temporary)
+- "User mentioned they're hungry" (temporary state)
+
+For each operation:
+- UPDATES: Provide the existing memory ID, new title, and new content
+- DELETIONS: Provide memory IDs that are no longer relevant
+- ADDITIONS: Provide title and content for brand new memories
+
+Be conservative - only add memories that will genuinely help personalize future conversations.`,
+    messages: convertToModelMessages(filteredMessages),
+  });
+
+  const { updates, deletions, additions } = memoriesResult.object;
+
+  // Filter out deletions that are also being updated
+  const filteredDeletions = deletions.filter(
+    (deletion) => !updates.some((update) => update.id === deletion)
+  );
+
+  // Process updates
+  await Promise.all(
+    updates.map((update) =>
+      updateMemory(update.id, {
+        title: update.title,
+        content: update.content,
+      })
+    )
+  );
+
+  // Process deletions
+  await Promise.all(
+    filteredDeletions.map((deletion) => deleteMemory(deletion))
+  );
+
+  // Process additions
+  await Promise.all(
+    additions.map((addition) =>
+      createMemory({
+        id: crypto.randomUUID(),
+        title: addition.title,
+        content: addition.content,
+      })
+    )
+  );
+}
diff --git a/src/app/api/chat/route.ts b/src/app/api/chat/route.ts
index b895bcd..d668524 100644
--- a/src/app/api/chat/route.ts
+++ b/src/app/api/chat/route.ts
@@ -21,6 +21,7 @@ import { searchTool } from "./search-tool";
 import { filterEmailsTool } from "./filter-tool";
 import { getEmailsTool } from "./get-emails-tool";
 import { memoryToText, searchMemories } from "@/app/memory-search";
+import { extractAndUpdateMemories } from "./extract-memories";
 
 // Allow streaming responses up to 30 seconds
 export const maxDuration = 30;
@@ -156,34 +157,44 @@ You are an email assistant that helps users find and understand information from
 <memories>
 Here are some memories that may be relevant to the conversation:
 
-${memories.map((memory) => `- ${memoryToText(memory.item)}`).join("\n")}
+${memories
+  .map((memory) => [
+    `<memory id="${memory.item.id}">`,
+    memoryToText(memory.item),
+    "</memory>",
+  ])
+  .join("\n")}
 </memories>
 
 <the-ask>
 Here is the user's question. Follow the multi-step workflow above to efficiently find and retrieve the information.
 </the-ask>
         `,
         tools: getTools(messages),
         stopWhen: [stepCountIs(10)],
       });
 
       writer.merge(
         result.toUIMessageStream({
           sendSources: true,
           sendReasoning: true,
         })
       );
 
       await generateTitlePromise;
     },
     generateId: () => crypto.randomUUID(),
     onFinish: async ({ responseMessage }) => {
       await appendToChatMessages(chatId, [responseMessage]);
+      await extractAndUpdateMemories({
+        messages: [...messages, responseMessage],
+        memories: memories.map((memory) => memory.item),
+      });
     },
   });
 
   // send sources and reasoning back to the client
   return createUIMessageStreamResponse({
     stream,
   });
 }
diff --git a/src/app/chat.tsx b/src/app/chat.tsx
index 5beb90d..65bad87 100644
--- a/src/app/chat.tsx
+++ b/src/app/chat.tsx
@@ -49,390 +49,393 @@ import { Button } from "@/components/ui/button";
 export const Chat = (props: { chat: DB.Chat | null }) => {
   const [backupChatId, setBackupChatId] = useState(crypto.randomUUID());
   const [input, setInput] = useState("");
   const searchParams = useSearchParams();
   const router = useRouter();
   const chatIdFromSearchParams = searchParams.get("chatId");
 
   const chatIdInUse = chatIdFromSearchParams || backupChatId;
   const { messages, sendMessage, status, regenerate } = useChat<MyMessage>({
     id: chatIdInUse,
     messages: props.chat?.messages || [],
     onData: (message) => {
       if (
         message.type === "data-frontend-action" &&
         message.data === "refresh-sidebar"
       ) {
         router.refresh();
       }
     },
+    onFinish: () => {
+      router.refresh();
+    },
     generateId: () => crypto.randomUUID(),
   });
 
   const ref = useFocusWhenNoChatIdPresent(chatIdFromSearchParams);
 
   const handleSubmit = (message: PromptInputMessage) => {
     const hasText = Boolean(message.text);
     const hasAttachments = Boolean(message.files?.length);
 
     if (!(hasText || hasAttachments)) {
       return;
     }
 
     startTransition(() => {
       sendMessage(
         {
           text: message.text || "Sent with attachments",
           files: message.files,
         },
         {
           body: {
             id: chatIdInUse,
           },
         }
       );
 
       setInput("");
 
       if (!chatIdFromSearchParams) {
         router.push(`/?chatId=${chatIdInUse}`);
         setBackupChatId(crypto.randomUUID());
       }
     });
   };
   return (
     <div className="relative flex-1 items-center flex flex-col min-h-0 w-full">
       <Conversation className="w-full">
         <ConversationContent className="max-w-4xl mx-auto w-full pb-40">
           {messages.map((message) => (
             <div key={message.id}>
               {message.role === "assistant" &&
                 message.parts.filter((part) => part.type === "source-url")
                   .length > 0 && (
                   <Sources>
                     <SourcesTrigger
                       count={
                         message.parts.filter(
                           (part) => part.type === "source-url"
                         ).length
                       }
                     />
                     {message.parts
                       .filter((part) => part.type === "source-url")
                       .map((part, i) => (
                         <SourcesContent key={`${message.id}-${i}`}>
                           <Source
                             key={`${message.id}-${i}`}
                             href={part.url}
                             title={part.url}
                           />
                         </SourcesContent>
                       ))}
                   </Sources>
                 )}
               {message.parts.map((part, i) => {
                 switch (part.type) {
                   case "text":
                     return (
                       <Fragment key={`${message.id}-${i}`}>
                         <Message from={message.role}>
                           <MessageContent>
                             <Response>{part.text}</Response>
                           </MessageContent>
                         </Message>
                         {message.role === "assistant" &&
                           i === messages.length - 1 && (
                             <Actions className="mt-2">
                               <Action
                                 onClick={() => regenerate()}
                                 label="Retry"
                               >
                                 <RefreshCcwIcon className="size-3" />
                               </Action>
                               <Action
                                 onClick={() =>
                                   navigator.clipboard.writeText(part.text)
                                 }
                                 label="Copy"
                               >
                                 <CopyIcon className="size-3" />
                               </Action>
                             </Actions>
                           )}
                       </Fragment>
                     );
                   case "reasoning":
                     return (
                       <Reasoning
                         key={`${message.id}-${i}`}
                         className="w-full"
                         isStreaming={
                           status === "streaming" &&
                           i === message.parts.length - 1 &&
                           message.id === messages.at(-1)?.id
                         }
                       >
                         <ReasoningTrigger />
                         <ReasoningContent>{part.text}</ReasoningContent>
                       </Reasoning>
                     );
                   case "tool-search":
                     return (
                       <Tool
                         key={`${message.id}-${i}`}
                         className="w-full"
                         defaultOpen={false}
                       >
                         <ToolHeader
                           title="Search"
                           type={part.type}
                           state={part.state}
                         />
                         <ToolContent>
                           <div className="space-y-4 p-4">
                             {/* Input parameters */}
                             {part.input && (
                               <div className="space-y-2">
                                 <h4 className="font-medium text-muted-foreground text-xs uppercase tracking-wide">
                                   Parameters
                                 </h4>
                                 <div className="text-sm">
                                   {part.input.keywords && (
                                     <div>
                                       <span className="font-medium">
                                         Keywords:
                                       </span>{" "}
                                       {part.input.keywords.join(", ")}
                                     </div>
                                   )}
                                   {part.input.searchQuery && (
                                     <div>
                                       <span className="font-medium">
                                         Search Query:
                                       </span>{" "}
                                       {part.input.searchQuery}
                                     </div>
                                   )}
                                 </div>
                               </div>
                             )}
 
                             {/* Email results */}
                             {part.state === "output-available" &&
                               part.output && (
                                 <EmailResultsGrid emails={part.output.emails} />
                               )}
 
                             {/* Error state */}
                             {part.state === "output-error" && (
                               <div className="space-y-2">
                                 <h4 className="font-medium text-muted-foreground text-xs uppercase tracking-wide">
                                   Error
                                 </h4>
                                 <div className="rounded-md bg-destructive/10 p-3 text-destructive text-sm">
                                   {part.errorText}
                                 </div>
                               </div>
                             )}
                           </div>
                         </ToolContent>
                       </Tool>
                     );
                   case "tool-filterEmails":
                     return (
                       <Tool
                         key={`${message.id}-${i}`}
                         className="w-full"
                         defaultOpen={false}
                       >
                         <ToolHeader
                           title="Filter Emails"
                           type={part.type}
                           state={part.state}
                         />
                         <ToolContent>
                           <div className="space-y-4 p-4">
                             {/* Input parameters */}
                             {part.input && (
                               <div className="space-y-2">
                                 <h4 className="font-medium text-muted-foreground text-xs uppercase tracking-wide">
                                   Filters
                                 </h4>
                                 <div className="text-sm space-y-1">
                                   {part.input.from && (
                                     <div>
                                       <span className="font-medium">From:</span>{" "}
                                       {part.input.from}
                                     </div>
                                   )}
                                   {part.input.to && (
                                     <div>
                                       <span className="font-medium">To:</span>{" "}
                                       {part.input.to}
                                     </div>
                                   )}
                                   {part.input.contains && (
                                     <div>
                                       <span className="font-medium">
                                         Contains:
                                       </span>{" "}
                                       {part.input.contains}
                                     </div>
                                   )}
                                   {part.input.before && (
                                     <div>
                                       <span className="font-medium">
                                         Before:
                                       </span>{" "}
                                       {new Date(
                                         part.input.before
                                       ).toLocaleString()}
                                     </div>
                                   )}
                                   {part.input.after && (
                                     <div>
                                       <span className="font-medium">
                                         After:
                                       </span>{" "}
                                       {new Date(
                                         part.input.after
                                       ).toLocaleString()}
                                     </div>
                                   )}
                                   {part.input.limit && (
                                     <div>
                                       <span className="font-medium">
                                         Limit:
                                       </span>{" "}
                                       {part.input.limit}
                                     </div>
                                   )}
                                 </div>
                               </div>
                             )}
 
                             {/* Email results */}
                             {part.state === "output-available" &&
                               part.output && (
                                 <EmailResultsGrid emails={part.output.emails} />
                               )}
 
                             {/* Error state */}
                             {part.state === "output-error" && (
                               <div className="space-y-2">
                                 <h4 className="font-medium text-muted-foreground text-xs uppercase tracking-wide">
                                   Error
                                 </h4>
                                 <div className="rounded-md bg-destructive/10 p-3 text-destructive text-sm">
                                   {part.errorText}
                                 </div>
                               </div>
                             )}
                           </div>
                         </ToolContent>
                       </Tool>
                     );
                   case "tool-getEmails":
                     return (
                       <Tool
                         key={`${message.id}-${i}`}
                         className="w-full"
                         defaultOpen={true}
                       >
                         <ToolHeader
                           title="Get Emails"
                           type={part.type}
                           state={part.state}
                         />
                         <ToolContent>
                           <div className="space-y-4 p-4">
                             {/* Input parameters */}
                             {part.input && (
                               <div className="space-y-2">
                                 <h4 className="font-medium text-muted-foreground text-xs uppercase tracking-wide">
                                   Parameters
                                 </h4>
                                 <div className="text-sm space-y-1">
                                   {part.input.ids && (
                                     <div>
                                       <span className="font-medium">
                                         Email IDs:
                                       </span>{" "}
                                       {part.input.ids.length} email
                                       {part.input.ids.length !== 1 ? "s" : ""}
                                     </div>
                                   )}
                                   <div>
                                     <span className="font-medium">
                                       Include Thread:
                                     </span>{" "}
                                     {part.input.includeThread ? "Yes" : "No"}
                                   </div>
                                 </div>
                               </div>
                             )}
 
                             {/* Full email content */}
                             {part.state === "output-available" &&
                               part.output && (
                                 <FullEmailDisplay emails={part.output.emails} />
                               )}
 
                             {/* Error state */}
                             {part.state === "output-error" && (
                               <div className="space-y-2">
                                 <h4 className="font-medium text-muted-foreground text-xs uppercase tracking-wide">
                                   Error
                                 </h4>
                                 <div className="rounded-md bg-destructive/10 p-3 text-destructive text-sm">
                                   {part.errorText}
                                 </div>
                               </div>
                             )}
                           </div>
                         </ToolContent>
                       </Tool>
                     );
                   default:
                     return null;
                 }
               })}
             </div>
           ))}
           {status === "submitted" && <Loader />}
         </ConversationContent>
         <ConversationScrollButton />
       </Conversation>
       <div className="absolute bottom-0 flex items-center justify-center w-full sm:px-6 px-5">
         <PromptInput
           onSubmit={handleSubmit}
           className="mb-4"
           globalDrop
           multiple
         >
           <PromptInputBody>
             <PromptInputAttachments>
               {(attachment) => <PromptInputAttachment data={attachment} />}
             </PromptInputAttachments>
             <PromptInputTextarea
               onChange={(e) => setInput(e.target.value)}
               value={input}
               ref={ref}
               autoFocus
             />
           </PromptInputBody>
           <PromptInputToolbar>
             <PromptInputTools>
               <PromptInputActionMenu>
                 <PromptInputActionMenuTrigger />
                 <PromptInputActionMenuContent>
                   <PromptInputActionAddAttachments />
                 </PromptInputActionMenuContent>
               </PromptInputActionMenu>
             </PromptInputTools>
             <PromptInputSubmit disabled={!input && !status} status={status} />
           </PromptInputToolbar>
         </PromptInput>
       </div>
     </div>
   );
 };
@@ -497,50 +500,51 @@ const EmailResultsGrid = ({
 const FullEmailDisplay = ({
   emails,
 }: {
   emails: Array<{
     id: string;
     threadId?: string;
     subject: string;
     from: string;
     to: string | string[];
     timestamp?: string;
     body: string;
   }>;
 }) => {
   return (
     <div className="space-y-2">
       <h4 className="font-medium text-muted-foreground text-xs uppercase tracking-wide">
-        Full Content ({emails.length} {emails.length === 1 ? "email" : "emails"})
+        Full Content ({emails.length} {emails.length === 1 ? "email" : "emails"}
+        )
       </h4>
       <div className="space-y-4">
         {emails.map((email, idx) => (
           <div
             key={idx}
             className="rounded-md border bg-muted/30 p-4 text-sm space-y-3"
           >
             <div>
               <div className="font-medium text-base">{email.subject}</div>
               {email.timestamp && (
                 <div className="text-muted-foreground text-xs mt-1">
                   {new Date(email.timestamp).toLocaleString()}
                 </div>
               )}
             </div>
             <div className="space-y-1">
               <div className="text-muted-foreground text-xs">
                 <span className="font-medium">From:</span> {email.from}
               </div>
               <div className="text-muted-foreground text-xs">
                 <span className="font-medium">To:</span>{" "}
                 {Array.isArray(email.to) ? email.to.join(", ") : email.to}
               </div>
             </div>
             <div className="pt-3 border-t whitespace-pre-wrap">
               {email.body}
             </div>
           </div>
         ))}
       </div>
     </div>
   );
 };
