commit a215416eaab9db36fba11f8fd5395f621ec5368c
Author: Matt Pocock <team@aihero.dev>
Date:   Fri Nov 14 14:13:26 2025 +0000

    10.03.03 Implemented app tagging on backend

diff --git a/src/app/api/chat/route.ts b/src/app/api/chat/route.ts
index 4c50b4d..697c1d0 100644
--- a/src/app/api/chat/route.ts
+++ b/src/app/api/chat/route.ts
@@ -24,9 +24,10 @@ import {
   annotateMessageHistory as annotateHITLMessageHistory,
   executeHITLDecisions,
   findDecisionsToProcess,
   ToolApprovalDataParts,
 } from "./hitl";
 import { getMCPTools } from "./mcp";
+import { filterToolsByApps, parseAppIdsFromMessage } from "./apps-config";
 
 // Allow streaming responses up to 30 seconds
 export const maxDuration = 30;
@@ -47,154 +48,158 @@ export type MyMessage = UIMessage<
 export async function POST(req: Request) {
   const body: {
     message: MyMessage;
     id: string;
   } = await req.json();
 
   const chatId = body.id;
 
   let chat = await getChat(chatId);
 
   const recentMessages = [...(chat?.messages ?? []), body.message].slice(
     -MESSAGE_HISTORY_LENGTH
   );
 
   const olderMessages = chat?.messages.slice(0, -MESSAGE_HISTORY_LENGTH);
 
   const validatedMessagesResult = await safeValidateUIMessages<MyMessage>({
     messages: recentMessages,
   });
 
   if (!validatedMessagesResult.success) {
     return new Response(validatedMessagesResult.error.message, { status: 400 });
   }
 
   const messages = validatedMessagesResult.data;
 
   const mostRecentMessage = messages[messages.length - 1];
 
   if (!mostRecentMessage) {
     return new Response("No messages provided", { status: 400 });
   }
 
   if (mostRecentMessage.role !== "user") {
     return new Response("Last message must be from the user", {
       status: 400,
     });
   }
 
   const mostRecentAssistantMessage = messages.findLast(
     (message) => message.role === "assistant"
   );
 
   const hitlResult = findDecisionsToProcess({
     mostRecentUserMessage: mostRecentMessage,
     mostRecentAssistantMessage,
   });
 
   if ("status" in hitlResult) {
     return new Response(hitlResult.message, {
       status: hitlResult.status,
     });
   }
 
   const allMemories = await searchMemories({ messages });
 
   const memories = allMemories.slice(0, MEMORIES_TO_USE);
 
   const oldMessagesToUse = await searchMessages({
     recentMessages: messages,
     olderMessages: olderMessages ?? [],
   }).then((results) =>
     results
       .slice(0, OLD_MESSAGES_TO_USE)
       .sort((a, b) => b.score - a.score)
       .map((result) => result.item)
   );
 
   console.log("oldMessagesToUse", oldMessagesToUse.length);
 
   const messageHistoryForLLM = [...oldMessagesToUse, ...messages];
 
   const stream = createUIMessageStream<MyMessage>({
     execute: async ({ writer }) => {
       let generateTitlePromise: Promise<void> | undefined = undefined;
 
       if (!chat) {
         const newChat = await createChat({
           id: chatId,
           title: "Generating title...",
           initialMessages: messages,
         });
         chat = newChat;
 
         writer.write({
           type: "data-frontend-action",
           data: "refresh-sidebar",
           transient: true,
         });
 
         generateTitlePromise = generateTitleForChat(messages)
           .then((title) => {
             return updateChatTitle(chatId, title);
           })
           .then(() => {
             writer.write({
               type: "data-frontend-action",
               data: "refresh-sidebar",
               transient: true,
             });
           });
       } else {
         await appendToChatMessages(chatId, [mostRecentMessage]);
       }
 
       const relatedChats = await searchForRelatedChats(chatId, messages);
 
-      const mcpTools = await getMCPTools();
+      const taggedAppIds = parseAppIdsFromMessage(body.message);
+      const allMcpTools = await getMCPTools();
+      const mcpTools = filterToolsByApps(allMcpTools, taggedAppIds);
 
       const messagesWithToolResults = await executeHITLDecisions({
         decisions: hitlResult,
-        mcpTools,
+        // We want to allow execution of any MCP tool, not just
+        // the ones that are tagged to the message
+        mcpTools: allMcpTools,
         writer,
         messages: messageHistoryForLLM,
       });
 
       const agent = createAgent({
         memories: memories.map((memory) => memory.item),
         relatedChats: relatedChats.map((chat) => chat.item),
         messages: messagesWithToolResults,
         model: google("gemini-2.5-flash"),
         stopWhen: stepCountIs(10),
         mcpTools,
         writer,
       });
 
       const result = agent.stream({
         messages: annotateHITLMessageHistory(messagesWithToolResults),
       });
 
       writer.merge(
         result.toUIMessageStream({
           sendSources: true,
           sendReasoning: true,
         })
       );
 
       await generateTitlePromise;
     },
     generateId: () => crypto.randomUUID(),
     onFinish: async ({ responseMessage }) => {
       await appendToChatMessages(chatId, [responseMessage]);
       await extractAndUpdateMemories({
         messages: [...messages, responseMessage],
         memories: memories.map((memory) => memory.item),
       });
       await reflectOnChat(chatId);
     },
   });
 
   // send sources and reasoning back to the client
   return createUIMessageStreamResponse({
     stream,
   });
 }
